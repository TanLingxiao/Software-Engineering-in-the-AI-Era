# 代理架构与组件

## 什么是编码代理？

编码代理（Coding Agent）是一个能够自主或半自主完成编程任务的 AI 系统。它结合了 LLM 的理解能力、推理能力和工具执行能力，可以像人类开发者一样进行编程工作。

## 编码代理的核心架构

```
┌─────────────────────────────────────────────────────────┐
│                    用户请求                              │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                  任务规划器                              │
│  - 理解用户意图                                          │
│  - 分解任务                                              │
│  - 制定执行计划                                          │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                  LLM 核心                                │
│  - 代码生成                                              │
│  - 推理决策                                              │
│  - 错误分析                                              │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                  工具管理器                              │
│  - 文件操作                                              │
│  - 代码执行                                              │
│  - API 调用                                              │
│  - 搜索查询                                              │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                  环境交互层                              │
│  - 文件系统                                              │
│  - 终端/Shell                                            │
│  - 编辑器集成                                            │
│  - 版本控制                                              │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                  反馈循环                                │
│  - 执行结果验证                                          │
│  - 错误处理                                              │
│  - 迭代优化                                              │
└─────────────────────────────────────────────────────────┘
```

## 核心组件详解

### 1. 任务规划器（Task Planner）

任务规划器负责理解用户的请求，并将其分解为可执行的子任务。

**功能**：
- 意图识别：理解用户想要做什么
- 任务分解：将复杂任务拆分为简单步骤
- 依赖分析：识别任务之间的依赖关系
- 优先级排序：确定执行顺序

**示例**：

```
用户请求："创建一个用户认证系统"

任务规划器分解：
1. 设计数据库模式（用户表）
2. 实现注册 API
3. 实现登录 API
4. 添加密码加密
5. 实现 JWT 令牌
6. 添加认证中间件
7. 编写测试
```

### 2. LLM 核心（LLM Core）

LLM 核心是代理的"大脑"，负责所有智能决策。

**功能**：
- 代码生成：根据需求生成代码
- 代码理解：分析现有代码
- 问题诊断：识别和解释错误
- 方案设计：提出解决方案

**提示模板**：

```python
# 任务规划提示
"""
你是一个编码代理。用户请求：{user_request}

请分析这个请求并：
1. 理解用户意图
2. 识别需要完成的任务
3. 将任务分解为可执行的步骤
4. 列出每个步骤的依赖关系
"""
```

### 3. 工具管理器（Tool Manager）

工具管理器负责管理和执行各种工具调用。

**常用工具**：

| 工具类型 | 功能 | 示例 |
|---------|------|------|
| 文件操作 | 读写文件 | `read_file`, `write_file`, `list_files` |
| 代码执行 | 运行代码 | `execute_python`, `run_tests` |
| 搜索 | 查找信息 | `search_code`, `search_web` |
| Git 操作 | 版本控制 | `git_commit`, `git_diff` |
| 终端 | 执行命令 | `run_command` |

**工具调用示例**：

```python
# 工具调用格式
{
    "tool": "read_file",
    "parameters": {
        "path": "src/main.py"
    }
}
```

### 4. 环境交互层（Environment Layer）

环境交互层负责与开发环境进行交互。

**支持的集成**：
- **文件系统**：读取、写入、搜索文件
- **终端**：执行命令行操作
- **编辑器**：与 VS Code、Cursor 等 IDE 集成
- **版本控制**：Git 操作
- **包管理器**：npm、pip、cargo 等

### 5. 反馈循环（Feedback Loop）

反馈循环确保代理能够从错误中学习并改进。

**流程**：
1. 执行操作
2. 收集结果
3. 验证结果
4. 如果失败，分析原因
5. 调整策略
6. 重新执行

```python
# 反馈循环伪代码
def execute_with_feedback(task):
    max_attempts = 3
    for attempt in range(max_attempts):
        result = execute(task)
        if is_successful(result):
            return result
        else:
            task = adjust_strategy(task, result.error)
    return "Failed after max attempts"
```

## 代理执行流程

### 完整的执行示例

```
用户请求："修复 login 函数中的 bug"

┌─────────────────────────────────────────────────────────┐
│ 步骤 1：任务规划                                         │
│ - 理解请求：修复 login 函数                              │
│ - 分解任务：                                              │
│   1. 定位 login 函数                                     │
│   2. 分析代码                                            │
│   3. 识别 bug                                            │
│   4. 修复 bug                                            │
│   5. 测试修复                                            │
└─────────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 步骤 2：定位函数                                         │
│ 工具调用：search_code("function login")                  │
│ 结果：找到 src/auth.py 中的 login 函数                   │
└─────────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 步骤 3：分析代码                                         │
│ 工具调用：read_file("src/auth.py")                      │
│ LLM 分析：发现密码比较使用 == 而不是 check_password()    │
└─────────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 步骤 4：修复 bug                                         │
│ LLM 生成修复代码                                         │
│ 工具调用：write_file("src/auth.py", new_code)           │
└─────────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 步骤 5：测试修复                                         │
│ 工具调用：run_tests()                                    │
│ 结果：所有测试通过                                        │
└─────────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────┐
│ 步骤 6：完成                                             │
│ 向用户报告：bug 已修复                                   │
└─────────────────────────────────────────────────────────┘
```

## 代理类型

### 1. 自主代理（Autonomous Agents）

- 完全自主决策
- 最少人工干预
- 适合明确、重复性任务

### 2. 半自主代理（Semi-Autonomous Agents）

- 需要人工确认关键决策
- 平衡自主性和控制
- 适合复杂、高风险任务

### 3. 辅助代理（Assistant Agents）

- 被动响应请求
- 不主动采取行动
- 适合问答、建议场景

## 设计原则

### 1. 可观测性

代理的决策过程应该是透明的：

```python
# 记录决策过程
def log_decision(agent, decision, reasoning):
    return {
        "agent": agent,
        "decision": decision,
        "reasoning": reasoning,
        "timestamp": datetime.now()
    }
```

### 2. 可控性

用户应该能够控制代理的行为：

- 设置自主级别
- 定义边界和约束
- 随时中断执行

### 3. 可恢复性

代理应该能够从错误中恢复：

- 保存中间状态
- 支持回滚操作
- 记录执行历史

### 4. 安全性

防止代理造成破坏：

- 沙箱执行环境
- 权限控制
- 操作确认机制

## 下一步

现在你已经了解了编码代理的架构，让我们学习如何让代理使用工具：

→ [工具使用与函数调用](02-tools-and-function-calling.md)
